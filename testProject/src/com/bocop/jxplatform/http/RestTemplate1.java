package com.bocop.jxplatform.http;import java.io.IOException;import java.net.Socket;import java.net.UnknownHostException;import java.security.KeyManagementException;import java.security.KeyStore;import java.security.KeyStoreException;import java.security.NoSuchAlgorithmException;import java.security.UnrecoverableKeyException;import java.security.cert.CertificateException;import java.security.cert.X509Certificate;import java.text.SimpleDateFormat;import java.util.Date;import java.util.Map;import javax.net.ssl.SSLContext;import javax.net.ssl.TrustManager;import javax.net.ssl.X509TrustManager;import org.apache.http.Header;import org.apache.http.conn.scheme.PlainSocketFactory;import org.apache.http.conn.scheme.Scheme;import org.apache.http.conn.scheme.SchemeRegistry;import org.apache.http.conn.ssl.SSLSocketFactory;import org.apache.http.entity.ByteArrayEntity;import org.apache.http.message.BasicHeader;import android.content.Context;import com.boc.jx.baseUtil.asynchttpclient.AsyncHttpClient;import com.boc.jx.baseUtil.asynchttpclient.AsyncHttpResponseHandler;import com.boc.jx.baseUtil.asynchttpclient.PersistentCookieStore;import com.boc.jx.baseUtil.asynchttpclient.RequestParams;import com.boc.jx.baseUtil.asynchttpclient.ResponseHandlerInterface;import com.boc.jx.common.util.ContentUtils;import com.boc.jx.constants.Constants;import com.bocop.jxplatform.config.BocSdkConfig;/** * 异步网络请求模板 *  * @author shefenfei * @version 3.0 * @date 2014-09-07 * @notice 推荐使用这个 * @api http://loopj.com/android-async-http/doc/com/loopj/android/http/package- *      summary.html */public final class RestTemplate1 {	/**	 * URL	 */	private static final String BASE_URL = BocSdkConfig.CONSUMER_URL;	/**	 * 实例化对象	 */	private AsyncHttpClient client = factoryHttpClinet();	/**	 * 缓存Cookie	 */	private PersistentCookieStore cookieStore;	private Context context;	/** 初始化相关参数 */	private AsyncHttpClient factoryHttpClinet() {		SSLSocketFactory sf = null;		try {			sf = new MySSLSocketFactory(KeyStore.getInstance(KeyStore.getDefaultType()));		} catch (KeyManagementException e) {			e.printStackTrace();		} catch (UnrecoverableKeyException e) {			e.printStackTrace();		} catch (NoSuchAlgorithmException e) {			e.printStackTrace();		} catch (KeyStoreException e) {			e.printStackTrace();		}		sf.setHostnameVerifier(SSLSocketFactory.ALLOW_ALL_HOSTNAME_VERIFIER);		SchemeRegistry registry = new SchemeRegistry();		registry.register(new Scheme("http", PlainSocketFactory.getSocketFactory(), 8080));		registry.register(new Scheme("https", sf, 443));		AsyncHttpClient client = new AsyncHttpClient(registry);		client.setTimeout(30000);		return client;	}	public RestTemplate1(Context c) {		this.context = c;		// cookieStore = new PersistentCookieStore(c);		// client.setCookieStore(cookieStore);	}	/**	 * get请求	 * 	 * @param url	 *            服务器地址	 * @param params	 *            请求参数	 * @param responseHandler	 *            响应处理器	 */	public void get(String url, RequestParams params, AsyncHttpResponseHandler responseHandler) {		// params.put("platform", "a");		client.get(getAbsoluteUrl(url), params, responseHandler);	}	/**	 * get请求	 * 	 * @param url	 *            服务器地址	 * @param map	 *            请求参数	 * @param responseHandler	 *            响应处理器	 */	public void get(String url, Map<String, String> map, AsyncHttpResponseHandler responseHandler) {		RequestParams params = new RequestParams(map);		get(url, params, responseHandler);	}	/**	 * post请求	 * 	 * @param url	 *            服务器地址	 * @param params	 *            请求参数 z	 * @param responseHandler	 *            响应处理器	 * 	 *            总行是uuid，分行是type	 * 	 *            总行的 这是只有报文头没有报文体的方式	 */	public void post(String url, RequestParams params, AsyncHttpResponseHandler responseHandler) {		getPublicHead();		client.post(getAbsoluteUrl(url), params, responseHandler);	}	public void getPublicHead() {		String action = ContentUtils.getSharePreStr(context, Constants.SHARED_PREFERENCE_NAME, Constants.ACCESS_TOKEN);		String userid = ContentUtils.getSharePreStr(context, Constants.SHARED_PREFERENCE_NAME, Constants.USER_ID);		client.addHeader("clentid", BocSdkConfig.CONSUMER_KEY);		client.addHeader("acton", action);		client.addHeader("userid", userid);		client.addHeader("chnflg", "1");		SimpleDateFormat format = new SimpleDateFormat("yyyyMMDD");		// 获取当前时间		String nowData = format.format(new Date(System.currentTimeMillis()));		client.addHeader("trandt", nowData);		SimpleDateFormat formatTime = new SimpleDateFormat("HHmmss");		// 获取当前时间		String nowTime = formatTime.format(new Date(System.currentTimeMillis()));		client.addHeader("trantm", nowTime);		client.addHeader("uuid", "");	}	/**	 * post请求	 * 	 * @param url	 *            服务器地址	 * @param map	 *            请求参数	 * @param responseHandler	 *            响应处理器	 */	public void post(String url, Map<String, String> map, AsyncHttpResponseHandler responseHandler) {		RequestParams params = new RequestParams(map);		post(url, params, responseHandler);	}	/**	 * 只在第一次请求时候调用,其它的POST请求不要调用这个方法,只为获取token	 * 	 * @param url	 * @param responseHandler	 */	public void post_crftoken(String url, RequestParams params, AsyncHttpResponseHandler responseHandler) {		params.put("platform", "a");		client.post(getAbsoluteUrl(url), params, responseHandler);	}	/**	 * 获取绝对路径	 * 	 * @param relativeUrl	 * @return	 */	private static String getAbsoluteUrl(String relativeUrl) {		if (relativeUrl.toLowerCase().startsWith("http://") || relativeUrl.toLowerCase().startsWith("https://"))			return relativeUrl;		System.out.println("nabudao99999999999999999-------------" + BASE_URL + relativeUrl);		return BASE_URL + relativeUrl;	}	/**	 * 武汉Eschool获取路径	 */	/**	 * 取消当前的网络请求	 * 	 * @param c	 */	public void cancelRequest(Context c) {		client.cancelRequests(c, true);	}	public void clearCookies() {		cookieStore.clear();	}	public void post_McisCsp(String url, String jsonString, ResponseHandlerInterface responseHandler) {		try {			/**			 * 测试sap9003			 */			String action = ContentUtils.getSharePreStr(context, Constants.SHARED_PREFERENCE_NAME, Constants.ACCESS_TOKEN);			String userid = ContentUtils.getSharePreStr(context, Constants.SHARED_PREFERENCE_NAME, Constants.USER_ID);			Header clientid = new BasicHeader("clentid", BocSdkConfig.CONSUMER_KEY);			Header type = new BasicHeader("type", "1");			Header useri = new BasicHeader("userid", userid);			Header actio = new BasicHeader("acton", action);			Header chnflg = new BasicHeader("chnflg", "1");			SimpleDateFormat format = new SimpleDateFormat("yyyyMMdd");			// 获取当前时间			String nowData = format.format(new Date(System.currentTimeMillis()));			Header trandt = new BasicHeader("trandt", nowData);			SimpleDateFormat formatTime = new SimpleDateFormat("HHmmss");			// 获取当前时间			String nowTime = formatTime.format(new Date(System.currentTimeMillis()));			Header trantm = new BasicHeader("trantm", nowTime);			String strMcis = "00E1091500010400018               38201402211715421392974142713858                                                                 00210HBLOCK";			String xmlString = "<?xml version='1.0' encoding='GBK'?><UTILITY_PAYMENT><CONST_HEAD><REQUEST_TYPE>0200</REQUEST_TYPE><TRN_CODE>GENERL</TRN_CODE><AGENT_CODE>42001915</AGENT_CODE></CONST_HEAD><DATA_AREA>";			String jsoncenter = "<JsonLenth>" + String.valueOf(jsonString.getBytes().length) + "</JsonLenth>" + "<JsonStr>" + jsonString + "</JsonStr>";			String BottomString = "</DATA_AREA></UTILITY_PAYMENT>";			xmlString = xmlString + jsoncenter + BottomString;			strMcis += xmlString;			System.out.println("params=============>" + strMcis);			byte[] mcis = strMcis.getBytes("UTF-8");			post(context, getAbsoluteUrl(url), new Header[] { clientid, type, useri, actio, chnflg, trandt, trantm }, mcis, responseHandler);		} catch (Exception e) {			e.printStackTrace();		}	}	public void post_UnloginMcisCsp(String url, String jsonString, ResponseHandlerInterface responseHandler) {		try {			/**			 * 测试sap9003			 */			String action = ContentUtils.getSharePreStr(context, Constants.SHARED_PREFERENCE_NAME, Constants.ACCESS_TOKEN);			String userid = ContentUtils.getSharePreStr(context, Constants.SHARED_PREFERENCE_NAME, Constants.USER_ID);			Header clientid = new BasicHeader("clentid", BocSdkConfig.CONSUMER_KEY);			Header type = new BasicHeader("type", "1");			Header useri = new BasicHeader("userid", userid);			Header actio = new BasicHeader("acton", action);			Header chnflg = new BasicHeader("chnflg", "1");			SimpleDateFormat format = new SimpleDateFormat("yyyyMMdd");			// 获取当前时间			String nowData = format.format(new Date(System.currentTimeMillis()));			Header trandt = new BasicHeader("trandt", nowData);			SimpleDateFormat formatTime = new SimpleDateFormat("HHmmss");			// 获取当前时间			String nowTime = formatTime.format(new Date(System.currentTimeMillis()));			Header trantm = new BasicHeader("trantm", nowTime);			String strMcis = "00E1091500010400018               38201402211715421392974142713858                                                                 00210HBUNLK";			String xmlString = "<?xml version='1.0' encoding='GBK'?><UTILITY_PAYMENT><CONST_HEAD><REQUEST_TYPE>0200</REQUEST_TYPE><TRN_CODE>GENERL</TRN_CODE><AGENT_CODE>42001915</AGENT_CODE></CONST_HEAD><DATA_AREA>";			String jsoncenter = "<JsonLenth>" + String.valueOf(jsonString.getBytes().length) + "</JsonLenth>" + "<JsonStr>" + jsonString + "</JsonStr>";			String BottomString = "</DATA_AREA></UTILITY_PAYMENT>";			xmlString = xmlString + jsoncenter + BottomString;			strMcis += xmlString;			byte[] mcis = strMcis.getBytes("UTF-8");			post(context, getAbsoluteUrl(url), new Header[] { clientid, type, useri, actio, chnflg, trandt, trantm }, mcis, responseHandler);		} catch (Exception e) {			e.printStackTrace();		}	}	/**	 * 分行网络请求	 * 	 * @param context	 * @param url	 * @param headers	 * @param mcis	 * @param responseHandler	 */	public void post(Context context, String url, Header[] headers, byte[] mcis, ResponseHandlerInterface responseHandler) {		final String contentType = "application/octet-stream; charset=UTF-8";		// client.addHeader("Content-Type", contentType);		// client.addHeader("Cache-Control", "no-cache");		// client.addHeader("Accept-Charset", "UTF-8");		// ByteArrayEntity entity = new ByteArrayEntity(mcis);		// client.post(context, url, headers, entity, contentType,		// responseHandler);		ByteArrayEntity entity = new ByteArrayEntity(mcis);		client.post(context, url, headers, entity, contentType, responseHandler);	}	private class MySSLSocketFactory extends SSLSocketFactory {		SSLContext sslContext = SSLContext.getInstance("TLS");		public MySSLSocketFactory(KeyStore truststore) throws NoSuchAlgorithmException, KeyManagementException, KeyStoreException, UnrecoverableKeyException {			super(truststore);			TrustManager tm = new X509TrustManager() {				@Override				public void checkClientTrusted(X509Certificate[] chain, String authType) throws CertificateException {				}				@Override				public void checkServerTrusted(X509Certificate[] chain, String authType) throws CertificateException {				}				@Override				public X509Certificate[] getAcceptedIssuers() {					return null;				}			};			sslContext.init(null, new TrustManager[] { tm }, null);		}		@Override		public Socket createSocket(Socket socket, String host, int port, boolean autoClose) throws IOException, UnknownHostException {			System.out.println("异常00------------------");			String token = ContentUtils.getSharePreStr(context, Constants.SHARED_PREFERENCE_NAME, Constants.ACCESS_TOKEN);			System.out.println("ssl异常后的Token--------" + token);			return sslContext.getSocketFactory().createSocket(socket, host, port, autoClose);		}		@Override		public Socket createSocket() throws IOException {			return sslContext.getSocketFactory().createSocket();		}	}}